% \chapter{Path Planning}\label{chap:pathplanning}
\chapter{路径规划}
\label{chap:pathplanning}
% Path-planning is an important primitive for autonomous mobile robots that lets robots find the shortest---or otherwise optimal---path between two points. Optimal paths could be paths that minimize the amount of turning, the amount of braking or whatever a specific application requires. Algorithms to find a shortest path are important not only in robotics, but also in network routing, video games and understanding protein folding.

路径规划是自主移动机器人的重要元素，它使机器人找到两点之间最短或最佳的路径。最佳路径可以是最小化转向、制动或特定应用所需要的路径。寻找最短路径的算法不仅对机器人很重要，而且对网络路由、视频游戏和理解蛋白质折叠也很重要。

% Path-planning requires a map of the environment and the robot to be aware of its location with respect to the map. We will assume for now that the robot is able to localize itself, is equipped with a map, and capable of avoiding temporary obstacles on its way. How to create a map, how to localize a robot, and how to deal with uncertain position information will be major foci of the reminder of this  book. The goals of this chapter are to

路径规划需要知道环境的地图，以及机器人在地图中的位置。现在我们假设机器人能够定位自己、地图已知，并能够避免临时障碍物。如何创建地图、如何定位机器人，以及如何处理不确定的位置信息将是本书剩下部分的主要焦点。本章的目标是：

\begin{itemize}
% \item introduce suitable map representations,
% \item explain basic path-planning algorithms  ranging from Dijkstra, to A*, D* and RRT,
% \item introduce variations of the path-planning problem, such as coverage path planning.

\item 介绍合适的地图表示
\item 介绍从Dijkstra到A*，D*和RRT的基本路径规划算法
\item 介绍路径规划问题的变种，如覆盖路径规划
\end{itemize}

% \section{Map representations}\label{sec:maps}
\section{地图表示}
\label{sec:maps}

% In order to plan a path, we somehow need to represent the environment in the computer. We differentiate between two complementary approaches: discrete and continuous approximations. In a discrete approximation, a map is sub-divided into chunks of equal (e.g., a grid or hexagonal map) or differing sizes (e.g., rooms in a building). The latter maps are also known as \emph{topological maps}.\index{Topological map} Discrete maps lend themselves well to a graph representation. Here, every chunk of the map corresponds to a vertex (also known as ``node''), which are connected by edges, if a robot can navigate from one vertex to the other. For example a road-map is a topological map, with intersections as vertices and roads as edges, labeled with their length (Figure \ref{fig:pathproblem}). Computationally, a graph might be stored as an adjacency or incidence list/matrix. A continuous approximation requires the definition of inner (obstacles) and outer boundaries, typically in the form of a polygon, whereas paths can be encoded as sequences of points defined by real numbers. Despite the memory advantages of a continuous representation, discrete maps are the dominant representation in robotics.

为了规划路径，我们需要在计算机中表示环境。有两种互补的方法：离散近似和连续近似。在离散近似中，地图被细分成大小相同的块（例如，网格或六边形地图）或大小不同的块（例如，建筑物中的房间）。后者的地图也称为\emph{拓扑图（Topological Map）}\index{拓扑图（Topological Map）}。离散地图很适用于表示图。这里，如果机器人可以从一个顶点导航到另一个顶点，那么地图的每个块对应于通过边缘连接的顶点（也称为“节点”）。例如，路线图是一个拓扑图，其中交叉点作为顶点，而道路作为边缘，以其长度标注（如图\ref{fig:pathproblem}）。在计算上，图可以存储为邻接\todo{incidence list}列表或矩阵。连续近似通常以多边形的形式定义内部（障碍物）和外部边界，而路径可以被编码为由实数定义的点的序列。尽管连续表示具有内存少的优势，但是机器人中主要使用离散地图。

% For mapping obstacles, the most common map is the \emph{occupancy grid} map\index{Occupancy grid}. In a grid map, the environment is discretized into squares of arbitrary resolution, e.g. 1cm x 1cm, on which obstacles are marked. In a probabilistic occupancy grid, grid cells can also be marked with the probability that they contain an obstacle. This is particularly important when the position of the robot that senses an obstacle is uncertain. Disadvantages of grid maps are their large memory requirements as well as computational time to traverse data structures with large numbers of vertices. A solution to this is storing the grid map as \emph{k-d tree}.\index{k-d tree (data structure)} A k-d tree recursively breaks the environment into $k$ pieces. For $k=4$, an area is broken into four pieces. Each of these pieces is again broken into four pieces and so on, until the desired resolution is reached. These pieces can easily be stored in a graph with each vertex having four children, which are the four pieces the vertex is broken into, or is a leaf of the tree. What makes this data structure attractive is that not all vertices need to be broken down to the smallest possible resolution. Instead only areas, which contain obstacles need to be further broken down. A grid map containing obstacles and the corresponding k-d tree, here a quadtree, are shown in Figure \ref{fig:gridvskdtree}. There is no silver bullet, and each application might require a different solution that could be a combination of different map types.

为了给障碍物建图，最常见的地图是\emph{占用网格（Occupancy grid）}地图\index{占用网格（Occupancy grid）}。网格图将环境离散成任意分辨率的方块（如，1cm$\times$1cm），上面标有障碍物。在概率占用网格中，网格单元以障碍物存在的概率来标记。当感知障碍物的机器人的位置不确定时，这是特别重要的。网格图的缺点是它们的内存需求大、计算时间长，因为需要遍历有大量顶点的数据结构。一种解决方案是将网格图存储为\emph{k-d树}\index{k-d树（数据结构）}。一个k-d树将环境递归地分解成$k$块。对于$k = 4$，一个区域分为四个块。每一块再次分成四块，等等，直到达到所需的分辨率。可以很容易地把这些块存储在四叉树中，树中每个顶点带有四个子顶点，每个子顶点可以继续分解为四块，也可以作为树的叶顶点（不继续分解）。该数据结构具有吸引力，因为不需要把所有的顶点都分解成最小。相反，只有含有障碍物的块需要进一步细分。包含障碍物的网格图和相应的k-d树（这里是四叉树）如图\ref{fig:gridvskdtree}所示。不同应用需要的解决方案可能不同，也可以是不同类型地图的组合。


\begin{figure}
\centering
\includegraphics[width=\textwidth]{figs/gridvskdtree.png}
% \caption{A grid map and its corresponding quadtree (k-d tree).\label{fig:gridvskdtree}}
\caption{网格图及其对应的k-d树（四叉树）。}
\label{fig:gridvskdtree}
\end{figure}


% There exist also every possible combination of discrete and continuous representation. For example, roadmaps for GPS systems are stored as topological maps that store the GPS coordinates of every vertex, but might also contain overlays of aerial and street photography or even 3D point clouds stored in a 8-d tree, also known as a \emph{Octree}\index{Octree}. These different maps are then used at different stages of the path planning stage.

离散表示和连续表示有很多种可能的组合。例如，GPS系统的路线图可以是存储每个顶点GPS坐标的拓扑图，也可能是包含存储在8-d树中的空中和街道摄影甚至三维点云的叠加层，也称为\emph{八叉树} \index{八叉树}。然后将这些地图用于路径规划的不同阶段。


% \section{Path-Planning Algorithms}
% The problem to find a ``shortest'' path from one vertex to another through a connected graph is of interest in multiple domains, most prominently in the internet, where it is used to find an optimal route for a data packet. The term ``shortest'' refers here to the minimum cumulative edge cost, which could be physical distance (in a robotic application), delay (in a networking application) or any other metric that is important for a specific application. An example graph with arbitrary edge-lengths is shown in Figure \ref{fig:pathproblem}.

\section{路径规划算法}
通过连接图找到从一个顶点到另一个顶点“最短”路径的问题在多个领域出现，最常见的是在互联网中用于为数据包找到最佳路由。这里，“最短”指的是最小累积边缘成本，这可能是物理距离最短（在机器人应用中）、延迟最少（在网络应用中）或对于特定应用很重要的其他度量。具有任意边长的示例如图\ref{fig:pathproblem}所示。

\begin{figure}[!htb]
\centering
\includegraphics[width=0.6\textwidth]{figs/dijkstra}
% \caption{A generic path planning problem from vertex I to vertex VI. The shortest path is I-II-III-V-VI with length 13.
\caption{从顶点I到顶点VI的一般路径规划问题。最短路径为I-II-III-V-VI，长度为13。}
\label{fig:pathproblem}
\end{figure}

% \subsection{Robot embodiment}
\subsection{机器人示例}
% In order to deal with the physical embodiment of the robot, which complicates the path-planning process, the robot is reduced to a point-mass and all the obstacles in the environment are grown by half of the longest extension of the robot from its center. This representation is known as configuration space \index{Configuration space}as it reduces the representation of the robot to its $x$ and $y$ coordinates in the plane. An example is shown in Figure \ref{fig:cspace}. The configuration space can now either be used as a basis for a grid map or a continuous representation.

机器人的物理实现使得路径规划过程复杂化，为了处理这种情况，机器人被简化为一个质点，然后环境中的所有障碍物轮廓增加机器人最长体长的一半。这种表示形式被称为\emph{配置空间（Configuration space）}\index{配置空间（Configuration space）}，因为它将机器人的表示简化为平面上的$x$和$y$坐标。一个例子如图\ref{fig:cspace}所示。配置空间现在可以被用作网格图或连续表示的基础。

\begin{figure}[!htb]
\centering
\includegraphics[width=0.9\textwidth]{figs/configurationspace}
% \caption{A map with obstacles and its representation in configuration space, which can be obtained by growing each obstacle by the robot's extension. \label{fig:cspace}}
\caption{具有障碍物的地图，及其在配置空间中的表示。可以通过扩大每个障碍物的轮廓来得到。 \label{fig:cspace}}
\end{figure}


% \subsection{Dijkstra's algorithm}\index{Dijkstra's Shortest Path Algorithm}
\subsection{Dijkstra算法}\index{Dijkstra最短路径算法（Dijkstra's Shortest Path Algorithm）}
% One of the earliest and simplest algorithms is Dijkstra's algorithm \cite{dijkstra1959note}. Starting from the initial vertex where the path should start, the algorithm marks all direct neighbors of the initial vertex with the cost to get there. It then proceeds from the vertex with the lowest cost to all of its adjacent vertices and marks them with the cost to get to them via itself if this cost is lower. Once all neighbors of a vertex have been checked, the algorithm proceeds to the vertex with the next lowest cost. Once the algorithm reaches the goal vertex, it terminates and the robot can follow the edges pointing towards the lowest edge cost.

Dijkstra算法是最早和最简单的算法之一\cite{dijkstra1959note}。该算法从路径的起始顶点开始，把所有相邻顶点标记为从起始顶点到达的所需成本。然后，选取成本最低的顶点标记其所有相邻的顶点，并选择最低成本来标记。如果该顶点的所有相邻顶点都已经被标记，那么算法重新选择成本最低的顶点继续。一旦标记到目标顶点，算法即终止。然后机器人可以沿着指向最低成本顶点的边前进。

% In Figure \ref{fig:pathproblem}, Dijkstra would first mark nodes II, III and IV with cost 3, 5 and 7 respectively. It would then continue to explore all edges of node II, which so far has the lowest cost. This would lead to the discovery that node III can actually be reached in $3+1<5$ steps, and node III would be relabeled with cost 4. In order to completely evaluate node II, Dijkstra needs to evaluate the remaining edge before moving on and label node VI with $3+12=15$.

在图\ref{fig:pathproblem}中，Dijkstra算法首先标记顶点II、III和IV，成本为3、5和7。然后，它将继续探索顶点II的所有相邻顶点，因为该顶点目前成本最低。然后会发现顶点III实际上可以以$3 + 1 <5$步长达到，顶点III将成本更新为4。Dijkstra算法需要评估剩余边并标记顶点VI为$3 + 12 = 15$，然后才能继续探索其他顶点。

% The node with the lowest cost is now node III (4). We can now relabel node VI with 14, which is smaller than 15, and label node V with $4+5=9$, whereas node IV remains at $4+3=7$. Although we have already found two paths to the goal, one of which better than the other, we cannot stop as there still exist nodes with unexplored edges and overall cost lower than 14. Indeed, continuing to explore from node V leads to a shortest path I-II-III-V-VI of cost 13, with no remaining nodes to explore.

成本最低的顶点现在是顶点III（4）。我们现在可以重新标记顶点VI为14（14小于15），标记顶点V为$4+5=9$，而顶点IV保持为$4+3=7$。虽然我们已经找到了目标的两条路径（其中一条比另一条更好），但是我们不能停止，因为仍然存在未完全探索的顶点，其总成本低于14。实际上，从顶点V继续探索会发现成本为13的最短路径I-II-III-V-VI，并且没有再需要探索的顶点。

% As Dijkstra would not stop until there is no node with lower cost than the current cost to the goal, we can be sure that a shortest path will be found if it exists. We can say that the algorithm is \emph{complete}.\index{Complete (algorithm)}

直到没有成本低于目标当前成本的顶点，Dijkstra算法才会停止，我们可以确定如果存在最短路径，该最短路径将被找到。我们可以说该算法是\emph{完备的（Complete）}\index{完备的Complete）【算法】}。

% As Dijkstra will always explore nodes with the least overall cost first, the environment is explored comparably to a wave front originating from the start vertex, eventually arriving at the goal. This is of course highly inefficient in particular if Dijkstra is exploring nodes away from the goal. This can be visualized by adding a couple of nodes to the left of node I in Figure \ref{fig:pathproblem}. Dijkstra will explore all of these nodes until their cost exceeds the lowest found for the goal. This can also be seen when observing Dijkstra's algorithm on a grid, as shown in Figure \ref{fig:dijkstragrid}.

由于Dijkstra算法始终最先探索总体成本最小的顶点，因此对环境的探索就像从起始顶点开始的波峰，最终达到目标。当然这是非常低效的，特别是如果Dijkstra算法探索远离目标的顶点。这可以通过在图\ref{fig:pathproblem}中的顶点I的左侧添加几个顶点来观察。Dijkstra算法将探索所有顶点，直到其成本超过目标的最小值。在网格上观察Dijkstra算法时也可以发现，如图\ref{fig:dijkstragrid}所示。

\begin{figure}[htb]
\centering
\includegraphics[width=0.9\textwidth]{figs/dijkstragrid}
% \caption{Dijkstra's algorithm finding a shortest path from `S' to 'G' assuming the robot can only travel laterally (not diagonally) with cost one per grid cell. Note the few number of cells that remain unexplored once the shortest path (grey) is found, as Dijkstra would always consider a cell with the lowest path cost first.\label{fig:dijkstragrid}}
\caption{Dijkstra算法寻找从“S”到“G”的最短路径，假设机器人只能沿着成本为1的网格单元行进（不是对角线）。请注意，由于Dijkstra总是最先考虑成本最低的单元格，找到最短路径（灰色）时几乎所有单元都被探索。}
\label{fig:dijkstragrid}
\end{figure}

% \subsection{A*}\label{sec:astar}\index{A* Shortest Path Algorithm}
\subsection{A*算法}\index{A*最短路径算法（A* Shortest Path Algorithm）}
\label{sec:astar}
% Instead of exploring in all directions, knowledge of an approximate direction of the goal could help avoiding exploring nodes that are obviously wrong to a human observer. Such special knowledge that such an observer has can be encoded using a \emph{heuristic function}\index{Heuristic function}, a fancier word for a ``rule of thumb''. For example, we could give priority to nodes that have a lower estimated distance to the goal than others. For this, we would mark every node not only with the actual distance that it took us to get there (as in Dijkstra's algorithm), but also with the estimated cost ``as the crows flies'', for example by calculating the Euclidean distance or the \emph{Manhattan distance}\index{Manhattan distance} between the vertex we are looking at and the goal vertex. This algorithm is known as A* \cite{hart1968formal}. Depending on the environment, A* might accomplish search much faster than Dijkstra's algorithm, and performs the same in the worst case. This is illustrated in Figure \ref{fig:astargrid} using the Manhattan distance metric, which does not allow for diagonal movements.

知道探索目标的大致方向可以避免探索对人类观察者明显错误的顶点，从而不用探索所有方向。这种特殊知识可以使用\emph{启发式函数（Heuristic function）}\index{启发式函数（Heuristic function）}来编码，这是“经验法则”的一个更别致的叫法。例如，我们可以优先考虑与其他顶点相比离目标估计距离较低的顶点。为此，我们不仅标记每个顶点实际距离／成本（如在Dijkstra的算法中），而且还标记估计成本，例如计算欧氏距离或者该顶点和目标顶点之间的\emph{曼哈顿距离（Manhattan distance）}\index{曼哈顿距离（Manhattan distance）}。该算法被称为A*算法 \cite{hart1968formal}。根据环境不同，A*可能比Dijkstra算法更快地完成搜索，并且在最坏的情况下执行一样多的操作。这在图\ref{fig:astargrid}中示例，使用曼哈顿距离度量，且不允许对角线运动。


\begin{figure}[htb]
\centering
\includegraphics[width=0.9\textwidth]{figs/astargrid}
% \caption{Finding a shortest path from `S' to 'G' assuming the robot can only travel laterally (not diagonally) with cost one per grid cell using the A* algorithm. Much like Dijkstra, A* evaluates only the cell with the lowest cost, but takes an estimate of the remaining distance into account.\label{fig:astargrid}}
\caption{假设机器人只能使用A*算法沿着成本为1的网格单元（不能走对角线）来寻找从“S”到“G”的最短路径。像Dijkstra算法一样，A*算法只探索成本最低的单元格，但A*算法还考虑剩余距离的估计。}
\label{fig:astargrid}
\end{figure}

% An extension of A* that addresses the problem of expensive re-planning when obstacles appear in the path of the robot, is known as D* \cite{stentz1994optimal}. Unlike A*, D* starts from the goal vertex and has the ability to change the costs of parts of the path that include an obstacle. This allows D* to re-plan around an obstacle while maintaining most of the already calculated path.\index{D*}

A*算法的扩展解决了当障碍物出现在机器人路径中时耗时的重新规划问题，被称为D*算法\cite{stentz1994optimal}。与A*算法不同，D*算法从目标顶点开始，有改变含有障碍物的路径成本的能力。这样可以让D*算法在保持大部分已经计算的路径的同时重新规划绕开障碍物。\index{D*算法}

% A* and D* become computationally expensive when either the search space is large, e.g., due to a fine-grain resolution required for the task, or the dimensions of the search problem are high, e.g. when planning for an arm with multiple degrees of freedom. Solutions to these problems are provided by sampling-based path planning algorithms that are described further below.

当搜索空间大（例如，由于任务所需的细粒度分辨率）或者搜索问题的维度高（例如，规划具有多个自由度的手臂）时，A*算法和D*算法在计算上变得耗时。这类问题的解决方案是基于采样的路径规划算法，下面会进一步描述。

% \section{Sampling-based Path Planning}
\section{基于采样的路径规划}

% The previous sections have introduced a series of complete algorithms for the path planning problem, i.e. they will find a solution eventually if it exists. Complete solutions are often unfeasible, however, when the possible state space is large. This is the case for robots with multiple degrees of freedom such as arms. In practice, most algorithms are only \emph{resolution complete}\index{Resolution complete}, i.e., only complete if the resolution is fine-grained enough, as the state-space needs to be somewhat discretized for them to operate (e.g., into a grid) and some solutions might be missed as a function of the resolution of the discretization.

前面几节介绍了一系列用于路径规划问题的完备算法，即如果存在解决方案，它们将最终被找到。然而，当可能的状态空间很大时，完备的解决方案通常是不可行的。对于具有多重自由度的机器人（例如操作臂）就是这种情况。在实践中，大多数算法只是\emph{分辨率完备的（Resolution complete）}\todo{?}\index{分辨率完备的（Resolution complete）}，即只有在分辨率足够细的情况下才能完成，因为状态空间需要稍微离散化才能运行（例如，离散化成网格），并且一些解决方案由于离散化分辨率的原因可能被错过。

% Instead of evaluating all possible solutions or using a non-complete Jacobian-based inverse kinematic solution, sampling-based planners create possible paths by randomly adding points to a tree until some solution is found or time expires. As the probability to find a path approaches one when time goes to infinity, sampling-based path planners are \emph{probabilistic complete}\index{Probabilistic complete}. Prominent examples of sampling-based planners are \emph{Rapidly-exploring Random Trees} (RRT)\index{Rapidly-exploring Random Tree}\index{RRT}\cite{lavalle1998rapidly} and \emph{Probabilistic Roadmaps}\index{Probabilistic Roadmaps}\index{PRM}(PRM) \cite{kavraki1996probabilistic}. An example execution of RRT for an unknown goal, thereby reducing the path-planning problem to a search problem is shown in Figure \ref{fig:rrt}.

基于采样的规划器通过将点随机添加到树中创建可能的路径，直到发现某个解决方案或时间用完，而不是评估所有可能的解决方案，或使用非完备的基于雅可比的逆运动学解决方案。当时间到无穷大时，找到路径的概率接近于一，基于采样的路径规划器是\emph{概率完备的（Probabilistic Complete）}\index{概率完备的（Probabilistic Complete）}。基于采样的规划器的著名算法有\emph{快速搜索随机树（Rapidly-exploring Random Trees，RRT）}\index{快速搜索随机树（Rapidly-exploring Random Trees，RRT）}\cite{lavalle1998rapidly}和\emph{概率路线图（Probabilistic Roadmaps，PRM）}\index{概率路线图（Probabilistic Roadmaps，PRM）}\cite{kavraki1996probabilistic}。目标未知的RRT将路径规划问题简化为搜索问题，示例如图\ref{fig:rrt}所示。

\begin{figure}
\centering
\includegraphics[width=\textwidth]{figs/irrt}
% \caption{Counterclockwise: Random exploration of a 2D search space by randomly sampling points and connecting them to the graph until a feasible path between start and goal is found.\label{fig:rrt}}
\caption{逆时针方向：随机采样点并把它们连接到图中，从而随机搜索二维空间，直到发现起始点和目标点之间的可行路径。}
\label{fig:rrt}
\end{figure}

% This example illustrates well how a sampling-based planner can quickly explore a large portion of space and refines a solution as time goes on. Whereas RRT can be understood as growing a single tree from a robot's starting point until one of its branches hit a goal, probabilistic road-maps create a tree by randomly sampling points in the state-space, testing whether they are collision-free, connecting them with neighboring points using paths that reflect the kinematics of a robot, and then using classical graph shortest path algorithms to find shortest paths on the resulting structure. The advantage of this approach is clearly that such a probabilistic roadmap has to be created only once (assuming the environment is not changing) and can then be used for multiple queries. PRMs are therefore a \emph{multi-query} path-planning algorithm.\index{Multi-query (path-planning)} In contrast, RRT's are known as \emph{single-query}\index{Single-query (path-planning)} path-planning algorithms.

此示例很好的说明了基于采样的规划器是如何快速探索一个很大的空间的，并且可以随着时间的推移来精细改进解决方案。快速搜索随机树（RRT）可以被理解为从机器人的起始点生成单树，直到其一个分叉达到目标。概率路线图（PRM）从状态空间中随机采样点测试它们是否无碰撞，然后用符合机器人运动学的路径将它们与相邻点连接，最后使用经典的图最短路径算法来找到所得结构上的最短路径。这种方法的优点很明显，这样一个概率路线图只需被创建一次（假设环境没有改变），然后可以用于多次查询。概率路线图因此是一个\emph{多次查询（Multi-query）}路径规划算法\index{多次查询（Multi-query）【路径规划】}。相反，快速搜索随机树被称为\emph{单次查询（Single-query）}\index{单次查询（Single-query）【路径规划】}路径规划算法。

% In practice, the boundary between the different historic algorithms has become very diffuse, and single-query and multi-query variants of both RRT and PRM exist. It is important to note that there is no silver bullet algorithm/heuristic and even their parameter-sets are highly problem-specific. We will therefore limit our discussion on useful heuristics that are common to sampling-based planners.

实际上，不同历史性算法之间的边界已经变得非常模糊，快速搜索随机树和概率路线图的单查询和多查询变体也被提出。要注意，没有通用算法/启发式，甚至它们的参数集都是高度问题相关的。因此，我们将只讨论基于采样的规划器常见的有效启发式。

% \subsection{Basic Algorithm}
\subsection{基本算法}
% Let $ \mathcal{X}$ be a $ d$-dimensional state-space. This can either be the robot's state given in terms of translation and rotations (6 dimensions), a subset thereof, or the joint space with one dimension per possible joint angle. Let $ \mathcal{G} \subset \mathcal{X}$ be a  d-ball (d-dimensional sphere) in the state-space that is considered to be the goal, and $ t$ the allowed time. A tree planner proceeds as follows:

令$\mathcal{X}$为一个$d$维度的状态空间。这既可以是根据平移和旋转（6个维度）给出的机器人的状态（其子集），也可以是每个可能的关节角度为一个维度的关节空间。令$\mathcal{G}\subset\mathcal{X}$为目标的状态空间中的一个$d$维球体，允许的时间为$t$。一种树规划器进行如下：

\begin{verbatim}
Tree=Init(X,start);
WHILE ElapsedTime() < t AND NoGoalFound(G) DO
 newpoint = StateToExpandFrom(Tree);
 newsegment = CreatePathToTree(newpoint);
 IF ChooseToAdd(newsegment) THEN
  Tree=Insert(Tree,newsegment);
 ENDIF
ENDWHILE
return Tree
\end{verbatim}

% This process can be repeated on the resulting tree as long as time allows. This is known as an \index{AnyTime algorithm} \emph{AnyTime} algorithm. Given a suitable distance metric, the cost-to-goal can be stored at each node of the tree (much easier if growing the tree from the goal to start), which allows retrieving the shortest path easily. There are four key points in this algorithm:

只要时间允许，可以在所得的树上重复此过程。这被称为\emph{随时（AnyTime）}算法\index{随时算法（AnyTime algorithm）}。给定适当的距离度量，可以将到目标点的成本存储在树的每个顶点（从目标点开始生成该树更容易），这使我们可以轻松地检索最短路径。该算法有四个要点：

\begin{enumerate}
% \item Finding the next point to add to the tree (or discard) (StateToExpandFrom).
% \item Finding out where and how to connect this point to the tree taking into account the robot kinematics (CreatePathToTree).
% \item Testing whether this path is suitable, i.e., collision-free.
% \item Finding the next point to add.

\item 找到下一个要添加到树（或丢弃）的顶点（StateToExpandFrom）。
\item 根据机器人运动学，找出在哪及如何将该点连接到树上（CreatePathToTree）。
\item 测试此路径是否可行，即无碰撞。
\item 找到下一个要添加的顶点。
\end{enumerate}

% A prominent method is to pick a random point in the state-space and connect it to the closest existing point in the tree or to the goal. This requires searching all nodes in the tree and calculating their distance to the candidate point. Other approaches put preferences on nodes with fewer out-degrees (those which do not yet have very many connections) and chose a new point within its vicinity. Both approaches make it likely to quickly explore the entire state-space.

一个著名的方法是在状态空间中选择一个随机点，并将其连接到树上最接近的顶点或目标点。这需要搜索树中的所有顶点并计算它们到候选点的距离。另一种方法是找到出度（Out-degree）较少的顶点（即没有很多连接的顶点），并在其附近选择一个新点。这两种方法都能快速探索整个状态空间。

% If there are constraints imposed on the robot's path, for example the robot needs to hold a cup and therefore is not supposed to rotate its wrist, this dimension can simply be taken out of the state-space.

如果机器人路径上有约束（例如机器人需要握住杯子，因此不应该旋转手腕），相关维度可以直接从状态空间中排除。

% Once a possible path is found, this space can be reduced to the ellipsoid that bounds the maximal path-length. This ellipsoid can be constructed by mounting a wire of the maximum path length between start and goal and pushing it outward with a pen. All the area that can be reached with the pen constrained by the wire can contain a point that can possibly lead to a shorter path. This approach is particularly effective when running multiple copies of the same planner in parallel and exchanging the shortest paths once they are found \cite{otte2012}.

一旦发现了一个可能的路径，这个空间可以简化为限制最大路径长度的椭圆体。该椭圆体可以通过在起始点和目标点之间建立最大路径长度的线并用笔将其向外推。受约束的笔可以覆盖的区域包含一个可能产生较短路径的点。可以并行运行多个相同规划器的副本，一旦找到就相互交换最短路径，这种方法非常有效\cite{otte2012}。

% \subsection{Connecting Points to the Tree}
% A new point is classically connected to the closest point already in the tree or to the goal. This can be done by calculating the distance to all points already in the tree. This does not necessarily generate the shortest path, however. A recent improvement has been made by RRT*, which connects the point to the tree in a way that minimizes the overall path length. This can be done by considering all points in the tree within a d-ball (on a 2D map, $d=2$, i.e. a circle) from of fixed radius from the point to add and finding the point that minimizes the overall path length to the start.

\subsection{将顶点与树相连}
一般地会把新顶点连到树上最接近的顶点或目标点。这需要计算新顶点与树上的所有点的距离。但是这不一定会产生最短路径。RRT*做了改进，RRT*以最小化整个路径长度的方式将该点连接到树上。这要考虑来自以要添加点为原点、固定半径的$d$维球中的所有点（在2D地图上，$d=2$，即一个圆圈），并找到最小化到起始点的整体路径长度的点。

% Adding a point to the tree is also a good time to take into account the specific kinematics of a robot, for example a car. Here, a local planner can be used to generate a suitable trajectory that takes into account the orientation of the vehicle at each point in the tree.

向树上添加点也是考虑机器人（例如汽车）的特定运动学的好时机。在这里，可以使用局部规划器来产生考虑了车在树上每个顶点的方向的适当轨迹。

% \subsection{Collision Checking}
% Efficient algorithms for testing collisions deserve a dedicated lecture. While the problem is intuitive in configuration-space planning in 2D (the robot reduces to a point) and can be solved using a simple point-in-polygon test, the problem is more involved for manipulators that are subject to self-collision.

\subsection{碰撞检测}
用于测试碰撞的高效算法值得一节专门的讲座。尽管二维配置空间规划中的问题是直观的（机器人缩小到某一点），并且可以使用简单的多边形点测试来解决问题，但问题更多涉及到受自我碰撞约束的操作臂。

% As collision checking takes up to 90\% of the execution time in the path planning problem, a successful method to increase computational speed is ``lazy collision evaluation''\index{Lazy collision avoidance}. Instead of checking every point for a possible collision, the algorithm first finds a suitable path. Only then, it checks every segment of this path for collisions. In case some segments are in collision, they are deleted and the algorithm goes on, but keeps the segments of the successful path that were collision-free.

由于碰撞检测在路径规划问题中占用执行时间的$90\%$，提高计算速度的一种成功的方法是\emph{懒惰避障（Lazy Collision Avoidance）}\index{懒惰避障（Lazy Collision Avoidance）}。该算法首先找到一个合适的路径，而不检测每个点可能的碰撞。然后检测此路径的每一段。保持成功路径的所有段是无碰撞的，如果某些段有碰撞，则删除，然后算法继续进行。

% \section{Path Smoothing}
% As paths are randomly sampled, they will be most likely shakey and not optimal. For exampe, a grid-map will generate a series of sharp turns and a sampling-based approach will return zig-zag random paths. Results can be drastically improved by running an additional algorithm that smoothes the path. One way of doing this is to connect points of the path using splines, curves or even trajectory snippets that are known to be feasible for a specific platform. Alternatively, one can also use a model of the actual platform and use a feedback controller such as described in Section \ref{sec:fbmobile} for mobile robots and Section \ref{sec:invjac} for arms, sample a series of points in front of the robot, and generate a trajectory that the robot can actually drive. When combined with dynamics, this approach is known as \emph{model-predictive control}\index{Model-predictive control}. Care needs to be taken, however, that the resulting paths are indeed collision free.

\section{路径平滑}
因为路径是随机采样得到的，它们很可能是弯弯曲曲的\todo{shakey}而不是最佳的。例如，网格图会产生一系列急转弯，基于采样的方法会产生曲折的随机路径。运行一个平滑路径的算法可以大大改进结果。其中一种方法是使用已知对特定平台可行的样条线、曲线或轨迹片段来连接路径的点。或者也可以使用实际平台的模型，并使用反馈控制器。如第\ref{sec:fbmobile}节的移动机器人和第\ref{sec:invjac}节的操作臂，在机器人的前面采样一系列的点并产生机器人可以实际驱动的轨迹。当与动力学结合时，这种方法被称为\emph{模型预测控制（Model-Predictive Control，MPC）}\index{模型预测控制（Model-predictive control，MPC）}。值得一提的是所产生的路径确实是无碰撞的。


% \section{Planning at different length-scales}
% In practice, no one map representation and planning algorithm might be sufficient. To plan a route for a car, for example, might involve a coarse search over the street network such as performed by your car's navigation system, but not involve planning which lane to actually choose. Planning lanes and how to navigate round-abouts and intersections will then involve another layer of discrete planning. How to actually move the robot within a lane and avoid local obstacles, might then be best done with a sampling-based planning algorithm. Finally, trajectories need to be turned into wheel speeds and turn angles, possibly using some form of feedback control. This hierarchy is depicted in Figure \ref{fig:planninglayers}. Here, downward-pointing arrows indicate input that one planning layer provides to the one below. Upward-pointing arrows instead indicate exceptions that cannot be handled by the lower levels. For example, a feedback controller cannot handle obstacles well, requiring the sampling-based planning layer to come up with a new trajectory. Should the entire road be blocked, this planner would need to hand-off control the lane-based planner. A similar case can be made for manipulating robots, which also need to combine multiple different representations and controllers to plan and execute trajectories efficiently.

\section{在规模不同的尺度上规划}
实际上，没有一个地图表示和规划算法是完全足够的。例如，为汽车规划行进路线，可能会先在街道网络上进行粗略搜索（例如你汽车的导航系统），但不规划实际行驶的车道。然后，需要另一层离散规划来规划车道以及如何导航环状交叉路口和十字路口。如何将机器人实际移动到车道内并避免局部障碍物，使用基于采样的规划算法来完成可能是最好的。最后，需要某种形式的反馈控制将轨迹转化为轮速和转角。这种层次规划如图\ref{fig:planninglayers}所示。这里，向下的箭头\todo{typo in english version}表示一个规划层向下一层提供输入。向上的箭头表示不能被较低级别层处理的异常。例如，反馈控制器不能很好地处理障碍物，需要基于采样的规划层提供新的轨迹。如果整个道路被阻挡，这个规划器需要切换到基于车道的规划器。类似的情况适用于操作机器人，也需要组合多个不同的表示和控制器以有效地规划和执行路径。

\begin{figure}
\centering
\includegraphics[width=0.9\textwidth]{figs/planninglayers}
% \caption{Path-planning across different length scales, requiring a variety of map representations and planning paradigms. Arrows indicate information passed between layers.\label{fig:planninglayers}}
\caption{不同层次的路径规划，需要各种地图表示和规划范例。箭头表示信息在各层之间的传递。
\label{fig:planninglayers}}
\end{figure}

% Note that this representation does not include a reasoning level that encodes traffic rules and common sense. While some of these might be encoded using cost-functions, such as maximizing distance from obstacles or insuring smooth riding, other more complex behaviors such as adapting driving in the presence of cyclists or properties of the ground need to be implemented in an additional vertical layer that has access to all planning layers.

请注意，这种表示不包括对交通规则和常识的推理。虽然其中一些可能使用成本函数进行编码（例如最大化与障碍物的距离或确保平稳骑行），但是还需要在附加的垂直层中实施其他更复杂的行为（例如存在骑自行车者或不同地面性质的情况下自适应驾驶），此垂直层可以访问每个规划层。


% \section{Other path-planning applications}
% Once the environment has been discretized into a graph, we can employ other algorithms from graph theory to plan desirable robot trajectories. For example, floor coverage can be achieved by performing a depth-first search (DFS) or a breadth-first-search (BFS) on a graph where each vertex has the size of the coverage tool of the robot. ``Coverage'' is not only interesting for cleaning a floor: the same algorithms can be used to perform an exhaustive search of a configuration space, such as in the example shown in Figure \ref{fig:inversekinematics}, where we plotted the error of a manipulator arm in reaching a desired position over its configuration space. Finding a minimum in this plot using an exhaustive search solves the inverse kinematics problem. Similarly, the same algorithm can be used to systematically follow all links on a website till a desired depth (or actually retrieving the entire world-wide web).

\section{其他路径规划的应用}
一旦将环境离散成图，我们可以使用图论中的其他算法来规划所需的机器人轨迹。例如，可以通过在每个顶点与机器人一样大的图上执行深度优先搜索（Depth-First Search，DFS）或广度优先搜索（Breadth-First Search，BFS）来实现地板覆盖。“覆盖”不仅适用于清理底板，也可以使用相同的算法来对配置空间进行详尽的搜索，例如在图\ref{fig:inversekinematics}所示的例子中，我们绘制了操作臂在其配置空间上达到所需位置的误差。通过详尽搜索找到该图中的最小值可以解决这个逆运动学问题。类似地，可以使用相同的算法来系统地跟踪网站上的所有链接，直到所需的深度（或实际检索整个万维网）。

% Doing a DFS or a BFS might generate efficient coverage paths, but they are far from optimal as many vertices might be visited twice. A path that connects all vertices in a graph but passes every vertex only once is known as a \emph{Hamiltonian Path}.\index{Hamiltonian Path} A Hamiltonian path that returns to its starting vertex is known as a Hamiltonian Cycle. This problem is also known as the Traveling Salesman Problem (TSP), in which a route needs to be calculated that visits every city on his tour only once and is known to be NP Complete.\index{Traveling Salesman Problem}

执行DFS或BFS可能会生成有效的覆盖路径，但是它们远不是最佳的，因为很多顶点可能会被访问两次。连接图中所有顶点且每个顶点仅访问一次的路径称为\emph{汉密尔顿路径（Hamiltonian Path）}\index{汉密尔顿路径（Hamiltonian Path）}，返回到其起始顶点的哈密尔顿路径被称为哈密尔顿循环。这个问题也被称为旅行商问题（Traveling Salesman Problem，TSP）\index{旅行商问题（Traveling Salesman Problem，TSP）}，需要计算一条路线遍历每个城市仅且仅一次，这个问题是NP完备的（NP Complete）。

% \section{Summary and Outlook}
% Path planning is an ongoing research problem. Finding collision free paths for mechanisms with high degrees of freedom such as multiple arms operating in a common space, multi-robot systems, or systems involving dynamics (and therefore adding the derivatives of the state variables to the planning problem) might take unacceptably long to solve.

\section{总结和展望}
路径规划是一个持续的研究课题。为自由度很高的机器人寻找无碰撞路径可能需要不可接受的时长，例如多个操作臂在同一空间中操作、多机器人系统或涉及动力学的系统（并因此将状态变量的导数添加到规划问题中）。

% Although sampling-based path planners can drastically speed up the time to find some solution, they are not optimal and struggle with specific situations such as narrow passages. There is no ``silver bullet'' algorithm for solving all path planning problems and heuristics that lead to massive speed-up in one scenario might be detrimental in others. Also, algorithmic parameters are mostly ad-hoc and correctly tuning them to a specific environment might drastically increase performance.

虽然基于采样的路径规划器可以大大加快找到解决方案的时间，但是对于具体的情况（如狭窄的通道）它们并不是最佳的。不存在用于解决所有路径规划问题的通用算法，在一种情况下大规模加速的启发式算法在其他情况下可能起到反作用。此外，算法参数大多是问题特定的，特定环境中正确地调试这些参数可能会大大提高性能。


% \section*{Take-home lessons}
\section*{课后补充}
\begin{itemize}
% \item The first step in path planning is choosing a map representation that is appropriate to the application.
% \item The second step is to reduce the robot to a point-mass, which allows planning in the configuration space.
% \item This allows the application of generic shortest path finding algorithms, which have applications in a large variety of domains, not limited to robotics.
% \item A sampling-based planning algorithm finds paths by sampling random points in the environment. Heuristics are used to maximize the exploration of space and bias the direction of search. This makes these algorithms fast, but neither optimal nor complete.
% \item As the resulting paths are random, multiple trials might lead to totally different results.
% \item There is no one-size-fits-all algorithm for a path-planning algorithm and care must be taken to select the right paradigm (single-query vs. multi-query), heuristics, and parameters.

\item 路径规划的第一步是选择适合的地图表示。
\item 第二步是将机器人简化成一个质点，这使我们能在配置空间中进行规划。
\item 这也使我们可以应用常见的最短路径算法，它们在各种各样的领域中都有应用，不仅限于机器人。
\item 基于采样的规划算法通过随机采样环境中的点来找到路径。启发式用于最大限度地搜索空间并指导搜索方向。这使得这些算法快速找的有效路径，但这些算法既不是最优的也不是完备的。
\item 由于生成的路径是随机的，多次试验可能会产生完全不同的结果。
\item 不存在适合所有情况的路径规划算法，必须注意选择正确的范例（单查询与多查询）、启发式和参数。
\end{itemize}

% \section*{Exercises}\small
\section*{习题}\small
\begin{enumerate}
% \item How does the computational complexity of Dijkstra's algorithm change when moving from 2D to 3D search spaces?
% \item A* uses a ``heuristic'' to bias the search in the expected direction of the goal. Why can it only use a heuristic, not the actual length?
% \item Assuming points are sampled uniformly at random in a randomized planning algorithm. Calculate the limiting behaviour of the following ratio (number of points in tree)/(number of points sampled) as the number of points sampled goes to infinity. Assume the total area $A_{total}$ and the area of free space $A_{free}$ within are known.

% \item Assuming a kd-tree is used as a nearest-neighbour data structure, and points are sample uniformly at random, calculate the  run-time of inserting a point into a tree of size $N$. Use ``big-Oh'' notation, e.g. $\mathcal{O}(N)$.

% \item What other practical runtime concerns must one consider besides computational complexity alone when doing sampling based motion planning? Can you suggest ways to deal with these other concerns?

\item 从二维空间变到三维空间时，Dijkstra算法的计算复杂度如何变化？
\item A*使用启发式使搜索偏向预期的目标方向。为什么只能使用启发式，而不使用实际的长度？
\item 假设在随机规划算法中随机采样点。当采样点数达到无穷大时，计算以下比例（树中的点数）/（采样点数）的约束。假设总面积$A_{total}$和可用空间面积$A_{free}$已知。
\item 假设使用k-d树作为最近邻数据结构，并且随机采样顶点，计算将顶点插入到大小为$N$的树中的运行时间。使用大“O”表示法，例如$\mathcal{O}(N)$。
\item 在执行基于采样的运动规划时，除了计算复杂度之外，还有哪些实际运行时的问题必须考虑？你能提出处理这些其他问题的方法吗？
\end{enumerate}
\normalsize
